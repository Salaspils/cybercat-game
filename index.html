html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CyberCat: Ultra 3D</title>
    <script src="https://cdnjs.cloudflare.com"></script>
    <script src="https://telegram.org"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Inter', sans-serif; }
        #ui { position: fixed; top: 15px; width: 100%; display: flex; justify-content: space-between; z-index: 100; pointer-events: none; }
        .glass { background: rgba(0,0,0,0.8); border: 2px solid #00ffcc; padding: 10px 25px; border-radius: 20px; color: #fff; margin: 0 15px; pointer-events: auto; box-shadow: 0 0 20px rgba(0,255,204,0.3); }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="ui">
        <div class="glass">üí∞ <b id="bal">0</b></div>
        <div class="glass" style="border-color:#ff0066">üëæ BOSS HP: <b id="hp">1M</b></div>
    </div>

    <script>
        const tg = window.Telegram?.WebApp || { ready:()=>{}, expand:()=>{} };
        let score = 0, bossHp = 1000000;

        // --- 3D ENGINE INITIALIZATION ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a1a0a);
        scene.fog = new THREE.FogExp2(0x0a1a0a, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING (–†–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π —Å–≤–µ—Ç) ---
        const ambientLight = new THREE.AmbientLight(0x404040, 2); // –ú—è–≥–∫–∏–π –æ–±—â–∏–π —Å–≤–µ—Ç
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(50, 100, 50);
        scene.add(sunLight);

        // --- WORLD (HD –¢—Ä–∞–≤–∞) ---
        const loader = new THREE.TextureLoader();
        const grassTex = loader.load('https://www.transparenttextures.com');
        grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
        grassTex.repeat.set(100, 100);

        const planeGeo = new THREE.PlaneGeometry(1000, 1000);
        const planeMat = new THREE.MeshPhongMaterial({ color: 0x1a4d2e, map: grassTex });
        const ground = new THREE.Mesh(planeGeo, planeMat);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // --- PLAYER (CyberCat) ---
        const catGeo = new THREE.SphereGeometry(1, 32, 32);
        const catMat = new THREE.MeshStandardMaterial({ color: 0x00ffcc, emissive: 0x00ffcc, emissiveIntensity: 2 });
        const cat = new THREE.Mesh(catGeo, catMat);
        cat.position.y = 1;
        scene.add(cat);

        // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç üêà‚Äç‚¨õ –Ω–∞–¥ —Å—Ñ–µ—Ä–æ–π
        const catSprite = createTextSprite('üêà‚Äç‚¨õ', 120);
        catSprite.position.y = 2;
        cat.add(catSprite);

        // --- BOSS (3D Entity) ---
        const bossGeo = new THREE.BoxGeometry(4, 4, 4);
        const bossMat = new THREE.MeshStandardMaterial({ color: 0xff0066, emissive: 0xff0066, emissiveIntensity: 1 });
        const boss = new THREE.Mesh(bossGeo, bossMat);
        boss.position.set(10, 2, -10);
        scene.add(boss);

        const bossSprite = createTextSprite('üëæ', 150);
        bossSprite.position.y = 4;
        boss.add(bossSprite);

        // --- CONTROLS & ANIMATION ---
        camera.position.set(0, 15, 15);
        camera.lookAt(cat.position);

        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();

        window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([ground, boss]);

            intersects.forEach(intersect => {
                if (intersect.object === boss) {
                    score += 1000; bossHp -= 5000;
                    document.getElementById('bal').innerText = score.toLocaleString();
                    document.getElementById('hp').innerText = (bossHp/1000) + 'K';
                    tg.HapticFeedback?.impactOccurred('heavy');
                } else {
                    // –ü–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –∫–æ—Ç–∞ –≤ 3D
                    new Tween(cat.position, intersect.point, 500);
                }
            });
        });

        function createTextSprite(text, size) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 256;
            context.font = `${size}px Arial`;
            context.textAlign = 'center';
            context.fillStyle = 'white';
            context.fillText(text, 128, 160);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            return new THREE.Sprite(spriteMaterial);
        }

        // –ü—Ä–æ—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏ (–≤–º–µ—Å—Ç–æ Tween-–±–∏–±–ª–∏–æ—Ç–µ–∫–∏)
        function Tween(obj, target, duration) {
            const start = { x: obj.x, z: obj.z };
            const startTime = Date.now();
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                obj.x = start.x + (target.x - start.x) * progress;
                obj.z = start.z + (target.z - start.z) * progress;
                if (progress < 1) requestAnimationFrame(animate);
            }
            animate();
        }

        function animateWorld() {
            requestAnimationFrame(animateWorld);
            
            // –ö–∞–º–µ—Ä–∞ —Å–ª–µ–¥–∏—Ç –∑–∞ –∏–≥—Ä–æ–∫–æ–º –≤ 3D
            camera.position.x = cat.position.x;
            camera.position.z = cat.position.z + 20;
            camera.lookAt(cat.position);

            renderer.render(scene, camera);
        }

        animateWorld();
        tg.ready(); tg.expand();
    </script>
</body>
</html>
